# Flow9 labs

## Блок 1 - Знакомство с языком flow

- Написать функцию, преобразующую массив целых чисел в массив строк, например: [1, 2, 3] в ["1", "2", "3"], распечатать этот массив. Использовать функции: map, i2s, strGlue, println.

- Написать функцию, считающую сумму целых чисел в массиве: [1, 2, 3] в 6. Использовать функции: fold.
- Написать функцию, fib(n : int) -> [int], вычисляющую n первых чисел фиббоначчи: 0, 1, 1, 2, 3, 5, .... Сделать ее а) рекурсивной б) с хвостовой рекурсией в) с использованием ссылок на массив, сложности O( n ). Использовать: fold, concat, refArrayPush
- Дан массив целых чисел [n_1,...,n_k] и число m. Найти все пары индексов (i, j) такие, что n_i + n_j == m. Сигнатура функции: inds(a : [int], m : int) -> [Pair<int, int>]. Усложнение: сделать эту функцию сложности O(n log(n)), а не O(n^2). Использовать функции: foldi, makeTree, setTree, lookupTree. 

##  Блок 2 - знакомство с парсерами и работы с AST

- Написать PEG-парсер грамматики простых арифметических выражений, генерирующий AST дерево. (используя библиотеку lingo). Операции(как минимум): +, -, *, /, логарифм*

- Преобразовать AST дерево арифметических выражений обратно в строковую форму

- Реализовать калькулятор, вычисляющий значение арифметического выражения.

- Сделать этот калькулятор символьным, принимающим значения переменных из командной строки) Расширить язык функциями степени, дробями.

- Калькулятор для rpn, реализующий предыдущие пункты, на вход подается rpn выражение. (rpn->expr, expr->rpn, string->rpn, rpn->string, calculate_rpn).

- Реализовать функцию упрощения алгебраического выражения (трансформация AST дерева с сохранением семантики). Примеры: 1 * 2, 1 * 0, 1+0, 1-0, log(1), 2^1, 1^2, 1^0, 0^1, -(-1), 1+(-3), 1-(-3)11) 
- Реализовать функцию символьного дифференцирования алгебраического выражения (+ упрощение).